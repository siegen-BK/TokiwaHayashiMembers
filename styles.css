(function(){
  const table = document.getElementById('assignTable');
  const tbody = document.getElementById('tbody');
  const tableScroll = document.getElementById('tableScroll');
  const swapLane = document.getElementById('swapLane');

  // --- ユーティリティ：tbody内tr配列を取得
  function rows(){
    return Array.from(tbody.querySelectorAll('tr'));
  }

  // --- 行の境界（行間）リストを作成：各ギャップに1つボタン
  function layoutSwapButtons(){
    // クリア
    swapLane.innerHTML = '';

    const trs = rows();
    if(trs.length < 2) return;

    // スクロール領域の可視開始位置（左レーンの原点は上部固定直下）
    const scrollTop = tableScroll.scrollTop;

    // thead の高さ（先頭行固定分）
    const thead = table.querySelector('thead');
    const theadRect = thead.getBoundingClientRect();
    const theadHeight = theadRect.height; // = var(--table-head-row-height)想定

    // tableScroll のスクロール原点（ビューポート基準 → swap-lane基準へ補正）
    const scrollRect = tableScroll.getBoundingClientRect();
    const laneRect = swapLane.getBoundingClientRect();
    const laneTopInViewport = laneRect.top;

    // 各行の位置を測り、行と行の“境界”のYにボタンを置く
    for(let i=0; i<trs.length - 1; i++){
      const rowA = trs[i];
      const rowB = trs[i+1];
      const aRect = rowA.getBoundingClientRect();
      const bRect = rowB.getBoundingClientRect();

      // 行間の中央（ビューポート座標）
      const gapCenterInViewport = (aRect.bottom + bRect.top) / 2;

      // swap-lane の座標系に変換
      const yInLane = gapCenterInViewport - laneTopInViewport;

      // ヘッダー直下のマスクより上に出さない（視覚的にも上に出ない）
      // swap-lane自体が上部固定直下から始まるため、y<0は見えない。ここでの制限は不要だが保険で。
      if (yInLane < 0) continue;

      const btn = document.createElement('button');
      btn.className = 'swap-button';
      btn.type = 'button';
      btn.textContent = '入替'; // 白黒のみ
      btn.style.top = Math.round(yInLane - 10) + 'px'; // 高さ20pxの半分=10pxで中央合わせ

      // クリックで i行目と i+1行目 を入替
      btn.addEventListener('click', () => swapAdjacent(i, i+1));

      swapLane.appendChild(btn);
    }
  }

  // --- 2行の内容を入替（セル単位でswap）＋ DOMの順序も入替
  function swapAdjacent(indexA, indexB){
    const trs = rows();
    if (indexA < 0 || indexB >= trs.length) return;

    const a = trs[indexA];
    const b = trs[indexB];

    // セルのテキストを丸ごとswap（DOMを丸ごと入れ替える前にデータも交換したい場合に有効）
    const aCells = Array.from(a.children);
    const bCells = Array.from(b.children);
    const len = Math.min(aCells.length, bCells.length);

    for(let i=0; i<len; i++){
      const aHTML = aCells[i].innerHTML;
      aCells[i].innerHTML = bCells[i].innerHTML;
      bCells[i].innerHTML = aHTML;
    }

    // DOM順序も入替（視覚順序が変わる要件の場合）
    // 要件により「見た目のみ入替」か「行の順序も入替」か異なることがある。
    // ここでは順序の入替はしない（内容のみ入替）。
    // もし物理的に並び順も変えたいなら以下を有効化：
    // tbody.insertBefore(b, a);
    // ↑この場合は内容swapは不要なので削除する運用に変更してください。

    // 再レイアウト
    requestAnimationFrame(layoutSwapButtons);
  }

  // --- スクロールやリサイズで再配置
  tableScroll.addEventListener('scroll', () => {
    requestAnimationFrame(layoutSwapButtons);
  });
  window.addEventListener('resize', () => {
    requestAnimationFrame(layoutSwapButtons);
  });

  // --- 初期配置
  window.addEventListener('load', () => {
    layoutSwapButtons();
  });

  // --- tbodyの変更（行追加/削除）がある場合に備えMutationObserver（任意）
  const mo = new MutationObserver(() => requestAnimationFrame(layoutSwapButtons));
  mo.observe(tbody, { childList: true, subtree: false });
})();
